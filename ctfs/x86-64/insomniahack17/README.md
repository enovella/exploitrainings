baby - Pwn - 50 pts - created by grimmlin
==========================================

Baby's first... Should be easy!
Challenge : here (called "baby")
Running on: ```baby.teaser.insomnihack.ch:1337```


Exploit mitigations
=====================
Goal: To bypass NX, stack cookies, ASLR and PIE

```
gdb-peda$ checksec 
CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : FULL
```

Vulnerabilities
================
- Format string
- Stack-based buffer overflow
- Heap-based buffer overflow

Tools used
===========
- pwntools
- GDB PEDA plugin
- radare2
- IDA Pro
- ROPgadget


Strategy:
==========
1. Leak a libc address from the stack and calculate the libc base address
2. Leak the stack cookie
3. Trigger the buffer overflow and get RIP control
4. Do some rop magic



Registers controlled after crash
=================================
```
RBP: 0x4545454545454545 ('EEEEEEEE')
RSP: 0x7ffe895c44e8 ("DDDDDDDDAAA%AAsAABAA$AAn
RIP: 0x7fc5e80e94c7 (<dostack+181>: ret)
R13: 0x7ffe895c4650 ("A%pA%TA%qA%UA%r", 'A' <repeats 185 times>...)   //  [R13] --> offset 352 - size ~43
```


GDB breakpoints right before the ROP chain
===========================================
```
$ sudo gdb -q -p `pidof baby`
gdb-peda$ br *dostack+180
gdb-peda$ set follow-fork-mode child
gdb-peda$ c
```



1) Leak the stack cookie 
=========================
Cookie stored at the beginning of the function at [rbp - 8] Ref: [1]

- Prologue
```
br *dofmt+17 
   0x7f379ee674d9 <dofmt+17>:   mov    rax,QWORD PTR fs:0x28         // copy canary pointer into RAX
=> 0x7f379ee674e2 <dofmt+26>:   mov    QWORD PTR [rbp-0x8],rax       // copy the canary content into [RBP-0x8]
   0x7f379ee674e6 <dofmt+30>:   xor    eax,eax                       // zero out the canary 

br *dofmt+135
        RAX: 0x83511eb77edda800       
```

    
- Epilogue
```
br *dostack+160
   0x7fd9efbe14b2 <dostack+160>:    mov    rcx,QWORD PTR [rbp-0x8]
=> 0x7fd9efbe14b6 <dostack+164>:    xor    rcx,QWORD PTR fs:0x28
   0x7fd9efbe14bf <dostack+173>:    je     0x7fd9efbe14c6 <dostack+180>
   0x7fd9efbe14c1 <dostack+175>:    call   0x7fd9efbe0e30 <__stack_chk_fail@plt>
    
    RCX: 0xec3c87dd37f3f200
```
RCX takes the [RBP-8] and the cookie (fs:0x28) and XOR them. If !=0, then cookie was tampered with.


2) Leak the ```libc``` base address 
=========================
TODO


3)  Overflow RIP
================
```    
    Payload  = "A"* 1032 + cookie + RBP + RIP
```

4) Build the ROP chain
=======================
According to the x86_64 ABI, the first 6 integer or pointer arguments to a function are passed in registers. 
The first is placed in rdi, the second in rsi, the third in rdx, and then rcx, r8 and r9. 
Only the 7th argument and onwards are passed on the stack.
```
    RDI
    RSI
    RDX
    RCX
    R8
    R9
```

* Finding out ```system()``` address in libc:
```
rabin2 -is libc.so.remote |grep system
vaddr=0x00137c20 paddr=0x00137c20 ord=225 fwd=NONE sz=70 bind=GLOBAL type=FUNC name=svcerr_systemerr
vaddr=0x00045390 paddr=0x00045390 ord=584 fwd=NONE sz=45 bind=GLOBAL type=FUNC name=__libc_system
vaddr=0x00045390 paddr=0x00045390 ord=1351 fwd=NONE sz=45 bind=UNKNOWN type=FUNC name=system
```

* Finding ROP gadgets:
```
$ ROPgadget --binary libc.so.remote --only "pop|ret" | tee gadgets-remote.txt
```

Tricks:
========
Rename to libc.so.6 and pre-load it:
```
LD_LIBRARY_PATH=. ./baby
```

References
===========
[1].- https://xorl.wordpress.com/2010/10/14/linux-glibc-stack-canary-values/


Decompilation
==============

* handle()
```c
__int64 __fastcall handle(int fd)
{
  char choice; // [sp+10h] [bp-10h]@2
  __int64 cookie; // [sp+18h] [bp-8h]@1

  cookie = *MK_FP(__FS__, 40LL);
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          sendstr(
            fd,
            "Welcome to baby's first pwn.\n"
            "Pick your favorite vuln : \n"
            "   1. Stack overflow\n"
            "   2. Format string\n"
            "   3. Heap Overflow\n"
            "   4. Exit\n"
            "Your choice > ");
          recvlen(fd, (__int64)&choice, 2uLL);
          if ( choice != '2' )
            break;
          dofmt(fd);
        }
        if ( choice > '2' )
          break;
        if ( choice == '1' )
          dostack(fd);
      }
      if ( choice != '3' )
        break;
      doheap(fd);
    }
  }
  while ( choice != '4' );
  return 0LL;
}
```


* dostack()
```c
__int64 __fastcall dostack(int fd)
{
  int len; // ST1C_4@1
  __int64 result; // rax@1
  __int64 v3; // rcx@1
  char buf; // [sp+20h] [bp-410h]@1
  __int64 cookie; // [sp+428h] [bp-8h]@1

  cookie = *MK_FP(__FS__, 40LL);
  sendstr(fd, "How much bytes you want to send ? ");
  recv(fd, &buf, 10uLL, 0);
  len = atoi(&buf);
  recvlen(fd, (__int64)&buf, len);
  sendstr(fd, "Good luck !\n");
  result = 0LL;
  v3 = *MK_FP(__FS__, 40LL) ^ cookie;
  return result;
}
```



* dofmt()
```c
__int64 __fastcall dofmt(int fd)
{
  unsigned int recv; // [sp+1Ch] [bp-414h]@2
  char user_input[1032]; // [sp+20h] [bp-410h]@2
  __int64 cookie; // [sp+428h] [bp-8h]@1

  cookie = *MK_FP(__FS__, 40LL);
  sendstr(fd, "Simply type '\\n' to return\n");
  while ( 1 )
  {
    sendstr(fd, "Your format > ");
    recv = recvlen_until(fd, user_input, 1024uLL, "\n");
    if ( recv == 1 )
      break;
    printf("%d\n", recv);
    puts(user_input);
    user_input[recv] = 0;
    dprintf(fd, user_input);
  }
  return 0LL;
}
```