# simplebof

This exercise contains a basic stack-based buffer overflow with only the security mechanism ASLR in place. The binary `simplebof` is intended to be run on a Linux 32-bits machine with ASLR enabled in the kernel. 

Source code
-----------
The function `dummy` does not check the boundaries of the variable `args` provided by the user when copying it onto the stack `buffer`. Therefore, we can gain code execution by placing a crafted shellcode on the stack and jump into it when overwriting the program counter. Notice that stack is executable and ASLR is enabled.

```c
/*
 * This binary requires stack-boundary to 2 to keep stack aligned to 2^n
 *
 * $ gcc -mpreferred-stack-boundary=2 simplebof.c -m32 -o simplebof
 */

#include <stdio.h>
#include <string.h>

void trick(void)
{
   __asm__("jmp *%esp");
}

void dummy(char *arg)
{
   char buffer[64];

   strcpy(buffer, arg);
   printf("The argument is: %s\n", buffer);
}


int main(int argc, char *argv[])
{
   char *res;

   /* Check args */
   if (argc != 2) {
      printf("Usage: %s argument\n", argv[0]);
      return 1;
   }
   
   printf("Hello r2con\n");
   dummy(argv[1]);

   return 0;
}
```

Enable ASLR and compilation steps
---------------------------------
First of all, make sure you enable ASLR before compiling this exercise.

* Enable ASLR   
```bash
$ sudo bash -c 'echo 2 > /proc/sys/kernel/randomize_va_space'
```

* Compile with PIE and without stack-canaries  
```bash
$ gcc -mpreferred-stack-boundary=2 simplebof.c -fPIC -m32 -o simplebof -fno-stack-protector -z execstack
```

* Setuid the binary with root permissions (Optional)
```bash
$ sudo chown root simplebof  
$ sudo chmod +s simplebof
```

Overwriting the program counter (EIP)
-------------------------------------

To be continued-............